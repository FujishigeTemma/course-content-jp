# チュートリアル3: 「なぜ」モデル — Neuromatch Academy: Computational Neuroscience

https://compneuro.neuromatch.io/tutorials/W1D1_ModelTypes/student/W1D1_Tutorial3.html

**第1週、第1日: モデルの種類**

**Neuromatch Academy 作成**

**コンテンツ作成者:** マット・ラポート、バイロン・ギャルブレイス、コンラッド・コーディング

**コンテンツレビューアー:** ダリン・グオ、アイシュワリヤ・バルワニ、マディネ・サルヴェスタニ、メアリアム・ヴァジリ・パシュカム、マイケル・ワスコム、エラ・バティ

**ポストプロダクションチーム:** ガガナ・B、スピロス・チャブリス

ここで使用されているデータの一部を提供してくれた[Steinmetz *et al.* (2019)](https://www.nature.com/articles/s41586-019-1787-x)に謝意を表します。

# チュートリアルの目的

これは、神経データを理解するために使用される異なるモデルの3部シリーズの第3弾のチュートリアルです。第1部と第2部では、データを生成するメカニズムについて調査しました。このチュートリアルでは、私たちが観察したスパイキングデータをなぜそうしたのかを説明するためのモデルと技術について探求します。

異なるスパイキング行動がなぜ有益であるかを理解するために、エントロピーの概念について学びます。具体的には、以下のことを学びます：

- エントロピーを計算するコードの記述：情報の尺度
- いくつかのおもちゃの分布のエントロピーの計算
- Steinmetzデータセットからのスパイキング活動のエントロピーの計算

```
スライドをダウンロードしたい場合は、こちらからダウンロードしてください:https://osf.io/download/6dxwe/
```

# セットアップ

## フィードバックガジェットのインストールとインポート

```
# インポート
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

```

## 図の設定

## プロット関数

## データのダウンロード

# 「Why」モデル

## 動画1: 「Why」モデル

- YouTube
- Bilibili

```
動画はこちらで視聴できます: https://youtube.com/watch?v=OOIDEr1e5Gg
```

## フィードバックを提出する

# セクション1: 最適化と情報

*記号の説明は、概要の後にあるので、参照が必要な場合はそちらをご覧ください！*

ニューロンは、固定された時間の間にしか発火できません。スパイクを発する行為はエネルギーを消耗し、そのエネルギーは最終的に補充される必要があります。下流の計算のために効果的にコミュニケーションを行うために、ニューロンは限られたスパイクの能力を最大限に活用する必要があります。これは最適化の問題となります：

ニューロンが情報を伝達する能力を最大化するために、最適な発火方法は何でしょうか？

この問いに対して探求するためには、まず情報の定量的な尺度が必要です。情報の概念を導入したのはShannonであり、エントロピーとして次のように定義しました：

(131)

Hb(X)=−∑x∈Xp(x)logbp(x)

ここで、Hはエントロピーを表し、bを基数として測定され、p(x)は集合X内のすべての可能なイベントからイベントxを観測する確率です。この式の詳細な導出については、ボーナスセクション1を参照してください。

エントロピーを測定する最も一般的な基数はb=2であり、通常は情報の*ビット*として話しますが、他の基数も使用されます（例えば、b=eの場合は単位を*nat*と呼びます）。

まず、いくつかのシンプルな離散確率分布間でエントロピーがどのように変化するかを探求しましょう。これらは以降のチュートリアルでは、確率質量関数（PMF）と呼ぶことにします。ここでは、p(xi)が配列のi番目の値に等しいPMFを選びます。また、「mass」とは分布に含まれる確率質量の量を指します。

最初のPMFとして、確率質量が分布の中央に集中するものを選びます。

```
n_bins = 50  # 分布をサポートする点の数
x_range = (0, 1)  # 点に対応するように均等に分割されます

bins = np.linspace(*x_range, n_bins + 1)  # ビンの境界

pmf = np.zeros(n_bins)
pmf[len(pmf) // 2] = 1.0  # 中央の点にすべての質量を持たせます

# PMFを持っているので、サンプルをビン化する代わりに、`plt.hist`は適していません。
# 代わりに、PMFをステップ関数として直接プロットしてヒストグラムを可視化します：
pmf_ = np.insert(pmf, 0, pmf[0])  # これはプロットのステップをビンの境界と一致させるために必要です
plt.plot(bins, pmf_, drawstyle="steps")
# `fill_between`は領域のシェーディングを提供します
plt.fill_between(bins, pmf_, step="pre", alpha=0.4)
plt.xlabel("x")
plt.ylabel("p(x)")
plt.xlim(x_range)
plt.ylim(0, 1)
plt.show()

```

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3b82456-e74b-486f-8e43-331f7a6aa78d/W1D1_Tutorial3_22_0.png)

この分布からサンプルを抽選すると、毎回正確に同じ値が得られることがわかります。確率質量が1つのイベントに集中する分布は*決定論的*として知られています。

この決定論的な分布にはどれだけのエントロピーが含まれているのでしょうか？次の演習でこれを計算します。

## コーディング演習1: エントロピーの計算

最初の演習では、質量関数が与えられた離散確率分布のエントロピーを計算するメソッドを実装します。エントロピーは*ビット*の単位で興味があるため、正しい対数関数を使用することを確認してください。

log(0)は未定義です。NumPyの対数関数（例：`np.log2`）は、0で評価されると`np.nan`（「Not a Number」）を返します。通常、これらの未定義の項目 - 分布内の質量がゼロの点に対応します - はエントロピーを計算する合計から除外されます。

```
def entropy(pmf):
  """与えられた離散分布のシャノンエントロピーをビット単位で返します。

  これは分布内の情報の尺度です。完全に決定論的な分布では、サンプルが常に同じビンに見つかるため、サンプルから得られる情報はなく、エントロピーは0です。

  今のところ、`pmf`が適切に構成された分布として到着すると仮定します（つまり、`np.sum(pmf)==1`かつ`not np.any(pmf < 0)`）。

  Args:
    pmf (np.ndarray): 確率質量関数を、確率の配列として表した離散分布
  Returns:
    h (number): `pmf`の分布のエントロピー

  """
  ############################################################################
  # 生徒用演習: 与えられたPMFのエントロピーを計算します
  #   1. 質量のない点（`pmf==0`の点）を除外します。
  #      ヒント：これは`pmf>0`の点のみを含めることと同等です。
  #   2. シャノンエントロピー（ビット単位）の式を実装します。
  #  テストする準備ができたら、次の行のコメントを削除するか削除してください
  raise NotImplementedError("Exercise: implement the equation for entropy")
  ############################################################################

  # エラーを回避するために、ゼロでないエントリのみを残します。
  pmf = ...

  # シャノンエントロピー（ビット単位）の式を実装します。
  h = ...

  # 絶対値を返す（-0の結果を回避します）
  return np.abs(h)

# エントロピー関数を呼び出して結果を表示します
print(f"{entropy(pmf):.2f} bits")

```

*[解答はこちら](https://github.com/NeuromatchAcademy/course-content/tree/main/tutorials/W1D1_ModelTypes/solutions/W1D1_Tutorial3_Solution_f07b571c.py)*

### フィードバックを提出する

決定論的な分布からは全く驚くべきことはありません。手計算でこの計算を行った場合、単純に −1log21=−0=0 となります。

ピークの位置（つまり、すべての質量が存在する点とビン）を変更しても、エントロピーは変化しません。エントロピーは、サンプルが分布に対してどれだけ予測可能かについての尺度です。一つのピークはどの点にあっても決定論的です - 次のプロットはエントロピーがゼロであるPMFを示しています。

次のセルを実行して、エントロピーがゼロの別のPMFを可視化します。

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/69551ba5-cb7e-47a9-ab06-e31a4ef3ab4a/W1D1_Tutorial3_32_0.png)

確率質量を2つの点に均等に分割する分布はどうでしょうか？

次のセルを実行して、質量が分割されたPMFを可視化します。

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca038fb7-9af9-418e-bdb0-32549711b37b/W1D1_Tutorial3_35_0.png)

ここでは、エントロピーの計算は：−(0.5log20.5+0.5log20.5)=1 となります。

エントロピーは1ビットです。これは、ランダムサンプルを取る前に、サンプルが分布内のどの点に落ちるかについて1ビットの不確実性があることを意味します：それは最初のピークか2番目のピークのどちらかです。

同様に、ピークの一つを高く（つまり、その点が確率質量の大部分を保持）し、もう一つを低くすると、サンプルが1つの点に落ちるか他の点に落ちるかについての確実性が増すため、エントロピーが減少します：：−(0.2log20.2+0.8log20.8)≈0.72

ピークの数や重みを変更して、エントロピーがどのように変化するかを試してみてください。

確率質量をさらに多くの点に分割すると、

# セクション2: 情報、ニューロン、およびスパイク

*ここまでの推定所要時間: 20分*

## 動画2: 異なる分布のエントロピー

- YouTube
- Bilibili

```
動画はこちらで視聴できます: https://youtube.com/watch?v=o6nyrx3KH20
```

## フィードバックを提出する

Tutorial 1からのスパイクタイムとインタースパイク間隔（ISI）の議論を思い出してください。これらの測定値の情報内容（または分布のエントロピー）は、神経系に関する私たちの理論について何を示していますか？

3つの仮想的なニューロンを考えますが、それらはすべて同じISIの平均を持ち、異なる分布を持っています。

1. 決定論的
2. 一様分布
3. 指数分布

ISI分布の平均を固定することは、その逆を固定することに等しいです：ニューロンの平均発火率です。ニューロンが固定されたエネルギーバジェットを持ち、各スパイクのエネルギーコストが同じである場合、平均発火率を固定することで、エネルギー消費を正規化しています。これにより、異なるISI分布のエントロピーを比較する基礎が提供されます。つまり：ニューロンが固定された予算を持つ場合、他のすべてが等しい状態で、その出力の情報コンテンツを最大化するためには、どのようなISI分布を表現すべきでしょうか？

これらの3つの分布を構築し、それらのエントロピーがどのように異なるかを見てみましょう。

```
n_bins = 50
mean_isi = 0.025
isi_range = (0, 0.25)

bins = np.linspace(*isi_range, n_bins + 1)
mean_idx = np.searchsorted(bins, mean_isi)

# 1. all mass concentrated on the ISI mean
pmf_single = np.zeros(n_bins)
pmf_single[mean_idx] = 1.0

# 2. mass uniformly distributed about the ISI mean
pmf_uniform = np.zeros(n_bins)
pmf_uniform[0:2*mean_idx] = 1 / (2 * mean_idx)

# 3. mass exponentially distributed about the ISI mean
pmf_exp = stats.expon.pdf(bins[1:], scale=mean_isi)
pmf_exp /= np.sum(pmf_exp)

```

このセルを実行して、3つのPMFをプロットします。

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3713c713-c435-4b4e-aa46-cbd3111ea7f1/W1D1_Tutorial3_52_0.png)

```
print(
  f"Deterministic: {entropy(pmf_single):.2f} bits",
  f"Uniform: {entropy(pmf_uniform):.2f} bits",
  f"Exponential: {entropy(pmf_exp):.2f} bits",
  sep="\n",
)

```

# セクション3: データからISI分布のエントロピーを計算する

*ここまでの推定所要時間: 25分*

## セクション3.1: ヒストグラムから確率を計算する

### 動画3: ヒストグラムからの確率

- YouTube
- Bilibili

```
動画はこちらで視聴できます: https://youtube.com/watch?v=e2U_-07O9jo
```

## フィードバックを提出する

前の例では、理想化されたシナリオを示すためにPMFを手動で作成しました。実際のニューロンから記録されたデータからどのように計算すればよいでしょうか？

一つの方法は、以前計算したISIヒストグラムを使用して、次の式を使用して離散確率分布に変換することです：

(133)

pi=ni∑ini

ここでpiは特定の区間iにISIが含まれる確率であり、niはその区間で

観測されたISIの数です。

### コーディング演習3.1: 確率質量関数

2番目の演習では、ISIビンのカウントの配列から確率質量関数を生成するメソッドを実装します。

解を確認するために、Steinmetzデータセットから取得した実際のニューロンのデータのISIの確率分布を計算します。

```
def pmf_from_counts(counts):
  """与えられたカウントから合計して確率を推定します。"""
  ###########################################################################
  # 演習：PMFを計算します。次の行を削除して関数をテストしてください
  raise NotImplementedError("Student exercise: compute the PMF from ISI counts")
  ###########################################################################

  pmf = ...

  return pmf

# ニューロンのインデックスを取得
neuron_idx = 283

# SteinmetzデータからISIのカウントを取得
isi = np.diff(steinmetz_spikes[neuron_idx])
bins = np.linspace(*isi_range, n_bins + 1)
counts, _ = np.histogram(isi, bins)

# PMFを計算
pmf = pmf_from_counts(counts)

# 可視化
plot_pmf(pmf, isi_range)

```

*[解答はこちら](https://github.com/NeuromatchAcademy/course-content/tree/main/tutorials/W1D1_ModelTypes/solutions/W1D1_Tutorial3_Solution_960d622a.py)*

*Example output:*

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6da8e72b-d26f-48ff-9ef5-58e05b5eaa57/W1D1_Tutorial3_Solution_960d622a_0.png)

### フィードバックを提出する

## セクション3.2: pmfからエントロピーを計算する

### 動画4: pmfからエントロピーを計算する

- YouTube
- Bilibili

```
動画はこちらで視聴できます: https://youtube.com/watch?v=Xjy-jj-6Oz0
```

## フィードバックを提出する

実際のニューロンのスパイク活動の確率分布を持っているので、エントロピーを計算できます。

```
print(f"ニューロン {neuron_idx} のエントロピー: {entropy(pmf):.2f} bits")

```

### インタラクティブデモ3.2: ニューロンのエントロピー

上記の分布プロットとエントロピー計算を組み合わせて、データセット内の異なるニューロンがどのようにスパイク活動と相対情報量が異なるかを探索するためのインタラクティブなウィジェットを使用できます。ニューロン全体の平均発火率は固定されていないため、一様なISI分布を持つニューロンのエントロピーがより指数的な分布を持つニューロンよりも高い場合があります。

**セルを実行**してスライダーを有効にします。

# セクション4: Whyモデルについて考える

*チュートリアル開始からここまでの所要時間の目安: 35分*

## Think! 3: Whyモデルについて考える

グループで約10分間以下の質問について話し合ってください：

- 以前にWhyモデルを見たことはありますか？
- 以前にWhyモデルを作成したことはありますか？
- Whyモデルはなぜ役立つのですか？
- それらはいつ可能ですか？あなたの研究分野にはWhyモデルがありますか？
- Whyモデルを構築することから学ぶことは何ですか？

### フィードバックを提出する

# 要約

*チュートリアルの所要時間の目安: 45分*

## 動画5: モデルタイプの要約

- YouTube
- Bilibili

```
動画はこちらで視聴できます: https://youtube.com/watch?v=X4K2RR5qBK8
```

## フィードバックを提出する

おめでとうございます！最初のNMAチュートリアルを完了しました。この3部作のチュートリアルシリーズでは、Steinmetzデータセットに記録されたニューロンのスパイク行動を理解するために、さまざまなタイプのモデルを使用しました。

- "What"モデルを使用して、実際のニューロンのISI分布が指数分布に最も近いことを発見しました。
- "How"モデルを使用して、バランスの取れた興奮性と抑制性の入力、リーキーな膜によってニューロンのスパイク活動が指数的なISI分布を示すことがわかりました。
- "Why"モデルを使用して、平均スパイクが制約されている場合、指数的なISI分布が最も情報を含んでいることがわかりました。

# 記法

(134)

H(X)：確率変数Xのエントロピーb：基数（例：b=2またはb=ex）event xp(x)：イベントxが観測される確率ISI：インタースパイクインターバルnicount：インターバルiで観測されたISIの数piprobability：特定のインターバルi内のISIの確率

# ボーナス

## ボーナスセクション1: エントロピーの基礎

情報理論に関する彼の基本的な[1948年の論文](https://en.wikipedia.org/wiki/A_Mathematical_Theory_of_Communication)で、クロード・シャノンは確率質量pi∈p(X)を持つ離散分布のエントロピーを定義するための3つの基準から始めました：

1. Hはpiに対して連続であるべきです。
- つまり、Hは各点xi上の質量piに対する滑らかな変化に応じて滑らかに変化する必要があります。
1. すべての点が確率質量を等分している場合、pi=1/N、HはNの非減少関数であるべきです。
- つまり、XNがN個の離散点を持つサポートであり、p(x∈XN)が各点に一定の質量を割り当てる場合、H(X1)<H(X2)<H(X3)<…となる必要があります。
1. Hは（de）分布の等価な（invariant to）等価な（de）分解によって保存されるべきです。
- たとえば（シャノンの論文から）、質量（12,13,16）の3つの点にわたる離散分布がある場合、そのエントロピーは3つの選択肢の間で直接選択することによって表現され、H(12,13,16)が計算されます。しかし、以下の2つの選択肢の系列としても表現できます：
    1. 質量が1/2の点をサンプリングするかどうか（*not*は1/2で、最初の選択肢で与えられていない領域があります）。
    2. （1/2の確率で）最初の点をサンプリングしない場合、残りの2つの点、質量1/3と1/6をサンプリングします。
    
    したがって、この場合、H(12,13,16)=H(12,12)+12H(13,16)を要求します。

これらの3つの要件を満たす（線形スケーリングファクタを除いて）一意の関数があります：

(135)

Hb(X)=−∑x∈Xp(x)logbp(x)

ここで、対数の底b>1はエントロピーの単位を制御します。最も一般的な場合はb=2で、*ビット*の単位になります。b=eの場合は*nats*の単位になります。

この関数は、分布に対する自己情報の期待値として見ることができます：

(136)

Hb(X)=Ex∈

X[Ib(x)]Ib(x)=−logbp(x)

自己情報は確率の負の対数であり、分布からサンプリングされるイベントがどれだけ驚くべきものかを示す尺度です。p(x)=1のイベントは確実に発生するため、その自己情報はゼロ（それらが構成する分布のエントロピーも同様）であり、完全に予測可能です。イベントの確率が小さいほど、自己情報が大きくなり、そのイベントが観測されることがどれだけ驚くべきものかが増します。
